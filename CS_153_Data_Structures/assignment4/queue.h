 #ifndef QUEUE_H
#define QUEUE_H
//////////////////////////////////////////////////////////////////////
/// @file queue.h
/// @author James Anderson  CS 153 Section A
/// @brief Heder file for single linked class for assignment 4
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @class Queue
/// @brief Queue is used to create and edit a queue and 
/// includes funtions to add remove and iterate the queue.
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::Queue ()
/// @brief creates a new queue
/// @pre needs the type of variable to be sored in the Queue
/// @post creates a new empty queue  
/// @param generic holds the type of variable the queue will hold
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::Queue (Queue & l);
/// @brief creates a new queue and copys existing queue into it
/// @pre needs the type of variable to be sored in the queue and and 
/// exsiting queue of the same type
/// @post creates a new queue inhariting the variables of existing queue 
/// @param Queue & l holds the queue to be copied 
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::~Queue;
/// @brief destructor for Queue
/// @post clears the curent queue 
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>:: operator= (const Queue & l)
/// @brief alows you to assign one queue to another
/// @pre the two queue must be of the same type
/// @post copys one queue into the other 
/// @param const Queue & l holds the queue to be copied 
/// @return returns the curent queue 
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::push
/// @brief adds a value to the top of the queue
/// @post will add x to the top of the queue and increse the size 
/// @param x holds the value to be added to the queue
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::pop
/// @brief delets top value off the Queue 
/// @post decreses the queue size by one taking off the top variable
/// and will throw CONTAINER_EMPTY if the size is at 0
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::remove (generic x)
/// @brief removes all values mathing the specivied value
/// @post removes all values and decreses size of queue
/// @param x holds the variable value to be removed
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::clear ()
/// @brief clears all of the values in the Queue 
/// @post decreses the size to 0 and sets the head to null
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::front ()
/// @brief retunst the value of the front pointer
/// @post will reurn the front
/// @return returns the pointer m_front
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::size () const
/// @brief feeds back the size of the queue
/// @return returns the size of the queue 
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::empty () 
/// @brief tells whether or not the queue is empty
/// @return returns a bool with 1 for empty and 0 for not 
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::Iterator begin () const;
/// @brief returns an Iterator to the first node on the queue 
/// @return returns a pointer to the first node
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Queue<generic>::Iterator end () const;
/// @brief returns an Iterator to the last node on the queue 
/// @return returns a pointer to the last node
//////////////////////////////////////////////////////////////////////
#include "list.h"

template <class generic>
class Queue : private List<generic>
{
  public:
    Queue ();
    Queue (Queue &);
    ~Queue ();
    Queue & operator= (const Queue &);
    bool empty () const;
    unsigned int size () const;
    generic & front ();
    generic & back ();
    void push (generic);
    void pop ();
    void clear ();
};

#include "queue.hpp"
#endif
