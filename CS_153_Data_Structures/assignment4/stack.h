#ifndef STACK_H
#define STACK_H
//////////////////////////////////////////////////////////////////////
/// @file stack.h
/// @author James Anderson  CS 153 Section A
/// @brief Heder file for stack class for assignment 4
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @class Stack
/// @brief stack is used to create and edit a stack and 
/// includes funtions to add remove from the stack.
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::Stack ()
/// @brief creates a new stack
/// @pre needs the type of variable to be sored in the Stack
/// @post creates a new empty stack  
/// @param generic holds the type of variable the stack will hold
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::Stack (Stack & l);
/// @brief creates a new stack and copys existing stack into it
/// @pre needs the type of variable to be sored in the stack and and 
/// exsiting stack of the same type
/// @post creates a new stack inhariting the variables of existing stack 
/// @param stack & l holds the stack to be copied 
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::~Stack;
/// @brief destructor for stack
/// @post clears the curent stack 
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>:: operator= (const Stack & l)
/// @brief alows you to assign one stack to another
/// @pre the two stack must be of the same type
/// @post copys one stack into the other 
/// @param const Stack & l holds the stack to be copied 
/// @return returns the curent stack 
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::push (generic x)
/// @brief adds a value to the top of the stack
/// @post will add x to the top of the stack and increse the size 
/// @param x holds the value to be added to the stack
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::pop ()
/// @brief delets top value off the Stack 
/// @post decreses the stack size by one taking off the top variable
/// and will throw CONTAINER_EMPTY if the size is at 0
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::remove (generic x)
/// @brief removes all values mathing the specivied value
/// @post removes all values and decreses size of stack
/// @param x holds the variable value to be removed
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::clear ()
/// @brief clears all of the values in the Stack 
/// @post decreses the size to 0 and sets the head to null
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::front ()
/// @brief retunst the value of the front pointer
/// @post will reurn the front
/// @return returns the pointer m_front
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::size () const
/// @brief feeds back the size of the stack
/// @return returns the size of the stack 
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::empty () 
/// @brief tells whether or not the stack is empty
/// @return returns a bool with 1 for empty and 0 for not 
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::Iterator begin () const;
/// @brief returns an Iterator to the first node on the stack 
/// @return returns a pointer to the first node
////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////
/// @fn Stack<generic>::Iterator end () const;
/// @brief returns an Iterator to the last node on the stack 
/// @return returns a pointer to the last node
//////////////////////////////////////////////////////////////////////
#include "slist.h"

template <class generic>
class Stack : private SList<generic>
{
  public:
    Stack ();
    Stack (Stack &);
    ~Stack ();
    Stack & operator= (const Stack &);
    void push (generic);
    void pop ();
    void clear ();
    generic & top ();
    unsigned int size () const;
    bool empty () const;
};

#include "stack.hpp"
#endif
